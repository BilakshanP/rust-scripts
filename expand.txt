#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod functions {
    #![allow(dead_code, unused)]
    pub mod io_helpers {
        use std::io::{self, Write, BufRead};
        pub fn input(prompt: &str) -> io::Result<String> {
            {
                ::std::io::_print(
                    ::core::fmt::Arguments::new_v1(
                        &[""],
                        &[::core::fmt::ArgumentV1::new_display(&prompt)],
                    ),
                );
            };
            io::stdout().flush()?;
            io::stdin().lock().lines().next().unwrap().map(|x| x.trim_end().to_owned())
        }
    }
    pub mod rust_quirks {
        /// set_zero(&mut var)
        pub fn set_zero(x: &mut i32) {
            *x = 0;
        }
        #[allow(clippy::unused_unit)]
        pub fn increment<NumberType>(num: &mut NumberType) -> ()
        where
            NumberType: std::ops::Add<Output = NumberType> + Copy + From<u8>,
        {
            *num = *num + NumberType::from(1_u8);
        }
    }
    pub mod math_manipulation {
        pub fn inv_sqrt(float: f32) -> f32 {
            let halv: f32 = 0.5 * float;
            let f32_from_i32: f32 = f32::from_bits(1597463007 - (float.to_bits() >> 1));
            f32_from_i32 * 1.5 - halv * f32_from_i32.powi(3)
        }
        pub fn factorial(n: u32) -> f64 {
            (2..=n).fold(1.0, |acc: f64, x: u32| acc * x as f64)
        }
        pub fn power(x: f64, n: u32) -> f64 {
            (0..n).fold(1.0, |acc: f64, _| acc * x)
        }
        pub fn sin(x: f64) -> f64 {
            const TERMS: u32 = 10;
            let mut result: f64 = 0.0;
            let mut sign: f64 = 1.0;
            for i in 0..TERMS {
                let term: f64 = power(x, 2 * i + 1) / factorial(2 * i + 1);
                result += sign * term;
                sign *= -1.0;
            }
            result
        }
        pub fn cos(x: f64) -> f64 {
            const TERMS: u32 = 10;
            let mut result: f64 = 0.0;
            let mut sign: f64 = 1.0;
            for i in 0..TERMS {
                let term: f64 = power(x, 2 * i) / factorial(2 * i);
                result += sign * term;
                sign *= -1.0;
            }
            result
        }
        pub fn sin_cos(x: f64) -> (f64, f64) {
            const TERMS: u32 = 10;
            let mut sin_result: f64 = 0.0;
            let mut cos_result: f64 = 0.0;
            let mut sign: f64 = 1.0;
            for i in 0..TERMS {
                let cos_term: f64 = power(x, 2 * i) / factorial(2 * i);
                let sin_term: f64 = power(x, 2 * i + 1) / factorial(2 * i + 1);
                cos_result += sign * cos_term;
                sin_result += sign * sin_term;
                sign *= -1.0;
            }
            (sin_result, cos_result)
        }
    }
    pub mod read_write {
        use std::{io, io::Write, fs};
        use super::base64;
        pub fn append_to_file(path: &str, content: &[u8]) -> io::Result<()> {
            fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open(path)?
                .write_all(content)?;
            Ok(())
        }
        /// Reads non b64 data as b64 and gives vec
        pub fn read_as_b64(path: &str) -> io::Result<Vec<u8>> {
            Ok(base64::encode(&fs::read(path)?))
        }
        /// Reads b64 data as non b64 and gives vec
        pub fn read_from_b64(path: &str) -> io::Result<Vec<u8>> {
            Ok(base64::decode(&fs::read(path)?))
        }
        /// Reads non b64 data as b64 and gives str
        pub fn read_as_b64_to_str(path: &str) -> io::Result<String> {
            Ok(base64::vec2str_encode(&fs::read(path)?))
        }
        /// Reads b64 data as non b64 and gives str
        pub fn read_from_b64_to_str(path: &str) -> io::Result<String> {
            Ok(base64::vec2str_decode(&fs::read(path)?))
        }
        /// Takes non b64 data writes it as b64
        pub fn write_as_b64(path: &str, content: &[u8]) -> io::Result<()> {
            fs::write(path, base64::encode(content))
        }
        /// Takes b64 data writes it as non b64
        pub fn write_from_b64(path: &str, content: &[u8]) -> io::Result<()> {
            fs::write(path, base64::decode(content))
        }
    }
    pub mod base64 {
        const BASE64_CHARS: [char; 64] = [
            'A',
            'B',
            'C',
            'D',
            'E',
            'F',
            'G',
            'H',
            'I',
            'J',
            'K',
            'L',
            'M',
            'N',
            'O',
            'P',
            'Q',
            'R',
            'S',
            'T',
            'U',
            'V',
            'W',
            'X',
            'Y',
            'Z',
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g',
            'h',
            'i',
            'j',
            'k',
            'l',
            'm',
            'n',
            'o',
            'p',
            'q',
            'r',
            's',
            't',
            'u',
            'v',
            'w',
            'x',
            'y',
            'z',
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            '+',
            '/',
        ];
        const BASE64_INDEX: [u8; 64] = [
            b'A',
            b'B',
            b'C',
            b'D',
            b'E',
            b'F',
            b'G',
            b'H',
            b'I',
            b'J',
            b'K',
            b'L',
            b'M',
            b'N',
            b'O',
            b'P',
            b'Q',
            b'R',
            b'S',
            b'T',
            b'U',
            b'V',
            b'W',
            b'X',
            b'Y',
            b'Z',
            b'a',
            b'b',
            b'c',
            b'd',
            b'e',
            b'f',
            b'g',
            b'h',
            b'i',
            b'j',
            b'k',
            b'l',
            b'm',
            b'n',
            b'o',
            b'p',
            b'q',
            b'r',
            b's',
            b't',
            b'u',
            b'v',
            b'w',
            b'x',
            b'y',
            b'z',
            b'0',
            b'1',
            b'2',
            b'3',
            b'4',
            b'5',
            b'6',
            b'7',
            b'8',
            b'9',
            b'+',
            b'/',
        ];
        ///
        /// Derieved using:
        /// ```
        /// let mut values: Vec<isize> = vec![-1; 256];
        ///
        /// for i in 0..64 {
        ///     values[BASE64_CHARS[i] as usize] = i as isize
        /// }
        ///
        /// println!("{}", values);
        /// ```
        const VALID_VALUES: [isize; 256] = [
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            62,
            -1,
            -1,
            -1,
            63,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
        ];
        const BASE_MAP: &[u8; 36] = b"0123456789abcdefghijklmnopqrstuvwxyz";
        pub const BASE_MAP_EXTENDED: &[u8; 64] = b"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/";
        /// ```
        /// let mut new = vec![-1; 128];
        ///
        /// for (n, i) in b64::BASE_MAP_EXTENDED.iter().enumerate() {
        ///    new[*i as usize] = n as i32
        /// }
        /// println!("{:?}", new)
        /// ```
        const BASE_MAP_EXTENDED_INDEX: [i32; 128] = [
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            62,
            -1,
            -1,
            -1,
            63,
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            -1,
            -1,
            -1,
            -1,
            -1,
            -1,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            -1,
            -1,
            -1,
            -1,
            -1,
        ];
        const RADIX_CHARS: [char; 64] = [
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g',
            'h',
            'i',
            'j',
            'k',
            'l',
            'm',
            'n',
            'o',
            'p',
            'q',
            'r',
            's',
            't',
            'u',
            'v',
            'w',
            'x',
            'y',
            'z',
            'A',
            'B',
            'C',
            'D',
            'E',
            'F',
            'G',
            'H',
            'I',
            'J',
            'K',
            'L',
            'M',
            'N',
            'O',
            'P',
            'Q',
            'R',
            'S',
            'T',
            'U',
            'V',
            'W',
            'X',
            'Y',
            'Z',
            '+',
            '/',
        ];
        /// vec to vec
        pub fn encode(input: &[u8]) -> Vec<u8> {
            let mut encoded: Vec<u8> = Vec::new();
            let mut val: usize = 0;
            let mut bits: i32 = -6;
            let mask: usize = 0x3F;
            for c in input {
                val = (val << 8) + *c as usize;
                bits += 8;
                while bits >= 0 {
                    encoded.push(BASE64_INDEX[(val >> bits) & mask]);
                    bits -= 6;
                }
            }
            if bits > -6 {
                encoded.push(BASE64_INDEX[((val << 8) >> (bits + 8)) & mask]);
            }
            while encoded.len() % 4 != 0 {
                encoded.push(b'=')
            }
            encoded
        }
        /// vec to vec
        pub fn decode(input: &[u8]) -> Vec<u8> {
            let mut decoded: Vec<u8> = Vec::new();
            let mut val: isize = 0;
            let mut bits: i32 = -8;
            for c in input {
                if VALID_VALUES[*c as usize] == -1 {
                    if c == &b'=' {
                        break;
                    }
                    ::core::panicking::panic_fmt(
                        ::core::fmt::Arguments::new_v1(
                            &["", " is an invalid base64 literal"],
                            &[::core::fmt::ArgumentV1::new_display(&c)],
                        ),
                    )
                }
                val = (val << 6) + VALID_VALUES[*c as usize];
                bits += 6;
                if bits >= 0 {
                    decoded.push(((val >> bits) & 0xFF) as u8);
                    bits -= 8;
                }
            }
            decoded
        }
        pub fn str2str_encode(input: &str) -> String {
            let mut encoded: String = String::new();
            let mut val: usize = 0;
            let mut bits: i32 = -6;
            let mask: usize = 0x3F;
            for c in input.chars() {
                val = (val << 8) + c as usize;
                bits += 8;
                while bits >= 0 {
                    encoded.push(BASE64_CHARS[(val >> bits) & mask]);
                    bits -= 6;
                }
            }
            if bits > -6 {
                encoded.push(BASE64_CHARS[((val << 8) >> (bits + 8)) & mask]);
            }
            while encoded.len() % 4 != 0 {
                encoded.push('=')
            }
            encoded
        }
        pub fn str2str_decode(input: &str) -> String {
            let mut decoded: String = String::new();
            let mut values: Vec<isize> = ::alloc::vec::from_elem(-1, 256);
            for i in 0..64 {
                values[BASE64_CHARS[i] as usize] = i as isize;
            }
            let mut val: isize = 0;
            let mut bits: i32 = -8;
            for c in input.chars() {
                if values[c as usize] == -1 {
                    break;
                }
                val = (val << 6) + values[c as usize];
                bits += 6;
                if bits >= 0 {
                    decoded.push(((val >> bits) & 0xFF) as u8 as char);
                    bits -= 8;
                }
            }
            decoded
        }
        pub fn vec2str_encode(input: &[u8]) -> String {
            let mut encoded: String = String::new();
            let mut val: usize = 0;
            let mut bits: i32 = -6;
            let mask: usize = 0x3F;
            for c in input {
                val = (val << 8) + *c as usize;
                bits += 8;
                while bits >= 0 {
                    encoded.push(BASE64_INDEX[(val >> bits) & mask] as char);
                    bits -= 6;
                }
            }
            if bits > -6 {
                encoded.push(BASE64_INDEX[((val << 8) >> (bits + 8)) & mask] as char);
            }
            while encoded.len() % 4 != 0 {
                encoded.push('=')
            }
            encoded
        }
        pub fn vec2str_decode(input: &[u8]) -> String {
            let mut decoded: String = String::new();
            let mut val: isize = 0;
            let mut bits: i32 = -8;
            for c in input {
                if VALID_VALUES[*c as usize] == -1 {
                    if c == &b'=' {
                        break;
                    }
                    ::core::panicking::panic_fmt(
                        ::core::fmt::Arguments::new_v1(
                            &["", " is an invalid base64 literal"],
                            &[::core::fmt::ArgumentV1::new_display(&c)],
                        ),
                    )
                }
                val = (val << 6) + VALID_VALUES[*c as usize];
                bits += 6;
                if bits >= 0 {
                    decoded.push(((val >> bits) & 0xFF) as u8 as char);
                    bits -= 8;
                }
            }
            decoded
        }
        pub fn str2vec_encode(input: &str) -> Vec<u8> {
            let mut encoded: Vec<u8> = Vec::new();
            let mut val: usize = 0;
            let mut bits: i32 = -6;
            let mask: usize = 0x3F;
            for c in input.chars() {
                val = (val << 8) + c as usize;
                bits += 8;
                while bits >= 0 {
                    encoded.push(BASE64_INDEX[(val >> bits) & mask]);
                    bits -= 6;
                }
            }
            if bits > -6 {
                encoded.push(BASE64_INDEX[((val << 8) >> (bits + 8)) & mask]);
            }
            while encoded.len() % 4 != 0 {
                encoded.push(b'=')
            }
            encoded
        }
        /// ```
        /// todo!()
        /// ```
        pub fn str2vec_decode(input: &str) -> Vec<u8> {
            let mut decoded: Vec<u8> = Vec::new();
            let mut val: isize = 0;
            let mut bits: i32 = -8;
            for c in input.chars() {
                if VALID_VALUES[c as usize] == -1 {
                    if c == '=' {
                        break;
                    }
                    ::core::panicking::panic_fmt(
                        ::core::fmt::Arguments::new_v1(
                            &["", " is an invalid base64 literal"],
                            &[::core::fmt::ArgumentV1::new_display(&c)],
                        ),
                    )
                }
                val = (val << 6) + VALID_VALUES[c as usize];
                bits += 6;
                if bits >= 0 {
                    decoded.push(((val >> bits) & 0xFF) as u8);
                    bits -= 8;
                }
            }
            decoded
        }
        /// not just b64, custom implementation
        pub fn from_str_radix(number: u128, radix: u8) -> String {
            let radix: u128 = radix as u128;
            if number == 0 {
                return String::from("0");
            }
            if radix > 36 {
                ::core::panicking::panic_fmt(
                    ::core::fmt::Arguments::new_v1(
                        &["Can\'t have a radix greater than 36: "],
                        &[::core::fmt::ArgumentV1::new_display(&radix)],
                    ),
                )
            }
            let mut digits: Vec<char> = Vec::new();
            let mut num: u128 = number;
            while num > 0 {
                let remainder = num % radix;
                digits.push(BASE_MAP[remainder as usize] as char);
                num /= radix;
            }
            digits.reverse();
            let mut out_str = String::with_capacity(digits.len());
            for digit in digits {
                out_str.push(digit)
            }
            out_str
        }
        pub fn from_str_radix_extended(number: u128, radix: u8) -> String {
            let radix: u128 = radix as u128;
            if number == 0 {
                return String::from("0");
            }
            if radix > 64 {
                ::core::panicking::panic_fmt(
                    ::core::fmt::Arguments::new_v1(
                        &["Can\'t have a radix greater than 36: "],
                        &[::core::fmt::ArgumentV1::new_display(&radix)],
                    ),
                )
            }
            let mut digits: Vec<char> = Vec::new();
            let mut num: u128 = number;
            while num > 0 {
                let remainder = num % radix;
                digits.push(BASE_MAP_EXTENDED[remainder as usize] as char);
                num /= radix;
            }
            digits.reverse();
            let mut out_str = String::with_capacity(digits.len());
            for digit in digits {
                out_str.push(digit)
            }
            out_str
        }
        /// can overflow, custom implementation
        pub fn to_decimal(number: &str, radix: u32) -> u128 {
            if radix > 64 {
                ::core::panicking::panic_fmt(
                    ::core::fmt::Arguments::new_v1(
                        &["Radix greater that 64 is unsipported, provided radix: "],
                        &[::core::fmt::ArgumentV1::new_display(&radix)],
                    ),
                )
            }
            let mut decimal = 0;
            let mut power = 1;
            for ch in number.chars().rev() {
                if let Some(index) = RADIX_CHARS.iter().position(|&c| c == ch) {
                    if index > radix as usize {
                        ::core::panicking::panic_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &["Out of range digit ", " for radix "],
                                &[
                                    ::core::fmt::ArgumentV1::new_display(&ch),
                                    ::core::fmt::ArgumentV1::new_display(&radix),
                                ],
                            ),
                        )
                    }
                    decimal += index as u128 * power;
                    power *= radix as u128;
                } else if ch != '_' {
                    ::core::panicking::panic_fmt(
                        ::core::fmt::Arguments::new_v1(
                            &["Out of radix digit: "],
                            &[::core::fmt::ArgumentV1::new_display(&ch)],
                        ),
                    )
                }
            }
            decimal
        }
    }
    pub mod conversions {
        pub fn str_to_vec(string: &str) -> Vec<u8> {
            string.into()
        }
        pub fn vec_to_str(vector: &[u8]) -> String {
            let mut out_str = String::with_capacity(vector.len());
            for character in vector {
                out_str.push(*character as char)
            }
            out_str
        }
    }
    pub mod compression {
        use flate2::Compression;
        use flate2::read::GzDecoder;
        use flate2::write::GzEncoder;
        use std::io::{Read, Write};
        pub fn compress_data(
            data: &[u8],
            level: Compression,
        ) -> Result<Vec<u8>, std::io::Error> {
            let mut encoder: GzEncoder<Vec<u8>> = GzEncoder::new(Vec::new(), level);
            encoder.write_all(data)?;
            encoder.finish()
        }
        pub fn decompress_data(data: &[u8]) -> Result<Vec<u8>, std::io::Error> {
            let mut decoder: GzDecoder<&[u8]> = GzDecoder::new(data);
            let mut decompressed: Vec<u8> = Vec::new();
            decoder.read_to_end(&mut decompressed)?;
            Ok(decompressed)
        }
    }
    pub mod macros_ {}
}
fn main() {
    trait Numeric: Copy {}
    impl<T: Copy> Numeric for T {}
    trait Numerix: Copy + Clone + std::ops::Add<Output = Self> + From<u8> {}
    impl<T: Copy + Clone + std::ops::Add<Output = Self> + From<u8>> Numerix for T {}
}
